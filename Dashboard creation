# phonepe_dashboard_app.py
# python -m streamlit run phonepe_dashboard_app.py
import streamlit as st
import pandas as pd
import mysql.connector
import plotly.express as px
import requests
import json

# --- DB Connection ---
def get_db_connection():
    return mysql.connector.connect(
        host="localhost",
        user="root",
        password="Swethasubburaj12345",
        database="phonepe_data"
    )

def execute_query(query, params=None):
    try:
        with get_db_connection() as mydb:
            cursor = mydb.cursor(dictionary=True)
            cursor.execute(query, params or ())
            result = cursor.fetchall()
        return pd.DataFrame(result)
    except mysql.connector.Error as err:
        st.error(f"Error executing query: {err}")
        return pd.DataFrame()

# --- Global Config ---
st.set_page_config(page_title="PhonePe Dashboard", layout="wide")
GEO_URL = "https://gist.githubusercontent.com/jbrobst/56c13bbbf9d97d187fea01ca62ea5112/raw/e388c4cae20aa53cb5090210a42ebb9b765c0a36/india_states.geojson"
geo = json.loads(requests.get(GEO_URL).content)
quarter_map = {
    "Q1 (Jan-Mar)": 1,
    "Q2 (Apr-Jun)": 2,
    "Q3 (Jul-Sep)": 3,
    "Q4 (Oct-Dec)": 4
}

# --- Custom CSS Styling ---
st.markdown("""
    <style>
    /* Background gradient */
    .stApp {
        background: linear-gradient(135deg, #d8b4fe, #fbcfe8, #fef9c3);
    }

    /* Horizontal Menu Styling */
    .custom-menu {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #9333ea;
        padding: 15px;
        gap: 30px;
        border-radius: 12px;
        margin-bottom: 30px;
    }
    .menu-item {
        color: white;
        font-size: 1.1rem;
        font-weight: 500;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        transition: 0.2s;
    }
    .menu-item:hover {
        background-color: #c084fc;
        color: black;
    }
    .menu-selected {
        background-color: #6d28d9;
        font-weight: bold;
    }

    /* Dashboard Title */
    h1 {
        color: #7e22ce;
        font-size: 50px !important;
        text-align: center;
    }
    h3 {
        color: #1d4ed8;
        text-align: center;
    }

    /* Expander Styling */
    div.streamlit-expanderHeader {
        background-color: #f3e8ff;
        color: #6d28d9;
        font-weight: bold;
        border-radius: 8px;
        padding: 10px;
    }

    /* Card Styling */
    .card-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin-top: 30px;
    }
    .card {
        background: #fef9c3;
        padding: 24px;
        border-radius: 16px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        text-align: center;
        transition: all 0.3s ease;
    }
    .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 4px 14px rgba(0,0,0,0.15);
    }
    .card-title {
        font-size: 1rem;
        color: #444;
        margin-bottom: 10px;
        text-transform: uppercase;
    }
    .card-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: #111;
    }

    /* Button Styling */
    div.stButton > button {
        background-color: #9333ea;
        color: white;
        border-radius: 12px;
        padding: 10px 20px;
        font-size: 16px;
        font-weight: bold;
        transition: 0.2s;
    }
    div.stButton > button:hover {
        background-color: #c084fc;
        color: black;
    }
    </style>
""", unsafe_allow_html=True)

# --- Query wrapper ---
def run_query(query, params=None):
    conn = get_db_connection()
    df = pd.read_sql(query, conn, params=params)
    conn.close()
    return df

# --- Menu Options ---
menu_options = {
    "Home": "üè°",
    "Business Case Study": "üìÇ",
    "Case Study Dashboard": "üìë"
}

# Session state for menu
if "menu" not in st.session_state:
    st.session_state["menu"] = "Home"

# Build horizontal menu
cols = st.columns(len(menu_options))
for i, (name, icon) in enumerate(menu_options.items()):
    if cols[i].button(f"{icon} {name}"):
        st.session_state["menu"] = name

section = st.session_state["menu"]

# --- Page Content ---
if section == "Home":    
    st.markdown(
        "<h1>üìä PHONEPE DASHBOARD!</h1>",
        unsafe_allow_html=True
    )
    st.markdown(
        "<h3>Explore insights and analysis related to PhonePe transactions across <b>India</b>.</h3>",
        unsafe_allow_html=True
    )

    # Expander sections with colorful icons
    with st.expander("üìà Transaction Trends"):
        st.write("Track volumes by type, state, and district over time.")
    with st.expander("ü§ù User Engagement"):
        st.write("Understand how users interact with the app across states and districts.")
    with st.expander("üõ°Ô∏è Insurance Analysis"):
        st.write("Analyze adoption of insurance services at state and district levels.")
    with st.expander("üåê Interactive Visuals"):
        st.write("Visualize data using charts, maps, and filters for interactive exploration.")




# --- Business Case Study ---
elif section == "Business Case Study":
    st.title("üìä Business Case Study")
    sub_tab = st.selectbox("Explore analytics by:", ["Transaction", "User", "Insurance"])

    # Year & Quarter Dropdown (once only)
    years = ["All"] + [str(y) for y in range(2018, 2025)]
    quarters = ["All"] + list(quarter_map.keys())

    col1, col2 = st.columns(2)
    selected_year = col1.selectbox("Select Year", years)
    selected_quarter = col2.selectbox("Select Quarter", quarters)

    year = int(selected_year) if selected_year != "All" else None
    quarter = quarter_map[selected_quarter] if selected_quarter != "All" else None

    conditions = []
    params = []

    if year is not None:
        conditions.append("Years = %s")
        params.append(year)
    if quarter is not None:
        conditions.append("Quarter = %s")
        params.append(quarter)

    where_clause = "WHERE " + " AND ".join(conditions) if conditions else ""

    if sub_tab == "Transaction":
        st.subheader("üí≥ Transaction Overview")

        df = execute_query(f"""
            SELECT SUM(Transaction_count) AS TotalTransactions,
                   AVG(Transaction_count) AS AvgTransactions,
                   SUM(Transaction_amount) AS TotalRevenue,
                   AVG(Transaction_amount) AS AvgRevenue
            FROM aggregate_transaction
            {where_clause}
        """, tuple(params))

        col1, col2 = st.columns(2)
        col1.metric("Total Transactions", f"{df['TotalTransactions'][0]:,.0f}")
        col1.metric("Average Transactions", f"{df['AvgTransactions'][0]:,.2f}")
        col2.metric("Total Revenue (‚Çπ)", f"{df['TotalRevenue'][0]:,.2f}")
        col2.metric("Avg Revenue (‚Çπ)", f"{df['AvgRevenue'][0]:,.2f}")

        df_map = execute_query(f"""
            SELECT States, SUM(Transaction_count) AS TotalTransactions
            FROM map_transaction
            {where_clause}
            GROUP BY States
        """, tuple(params))

        fig = px.choropleth(df_map, geojson=geo, locations="States",
                            featureidkey="properties.ST_NM", color="TotalTransactions",
                            color_continuous_scale="Reds", title="State-wise Total Transactions")
        fig.update_geos(fitbounds="locations", visible=False)
        st.plotly_chart(fig, use_container_width=True)

        st.markdown("### üìå Top 10 States by Transaction Volume")
        df_top = df_map.sort_values(by="TotalTransactions", ascending=False).head(10)
        st.dataframe(df_top, use_container_width=True)

    elif sub_tab == "User":
        st.subheader("ü§ù User Engagement and Growth Strategy")

        df_total = execute_query(f"""
            SELECT SUM(RegisteredUser) as TotalUsers, SUM(AppOpens) as TotalOpens
            FROM map_user {where_clause}
        """, tuple(params))

        if not df_total.empty:
            st.metric("Total Registered Users", f"{int(df_total.iloc[0]['TotalUsers']):,}")
            st.metric("Total App Opens", f"{int(df_total.iloc[0]['TotalOpens']):,}")

        tab1, tab2, tab3 = st.tabs(["States", "Districts", "Pincodes"])

        with tab1:
            df_states = execute_query(f"""
                SELECT States, SUM(RegisteredUser) as TotalUsers
                FROM map_user {where_clause}
                GROUP BY States ORDER BY TotalUsers DESC LIMIT 10
            """, tuple(params))
            if not df_states.empty:
                st.markdown("#### üèÜ Top 10 States by Registered Users")
                st.dataframe(df_states, use_container_width=True)

        with tab2:
            df_districts = execute_query(f"""
                SELECT Districts, SUM(RegisteredUser) as TotalUsers
                FROM map_user {where_clause}
                GROUP BY Districts ORDER BY TotalUsers DESC LIMIT 10
            """, tuple(params))
            if not df_districts.empty:
                st.markdown("#### üèÜ Top 10 Districts by Registered Users")
                st.dataframe(df_districts, use_container_width=True)

        with tab3:
            df_pincodes = execute_query(f"""
                SELECT Pincodes, SUM(RegisteredUser) as TotalUsers
                FROM top_user {where_clause}
                GROUP BY Pincodes ORDER BY TotalUsers DESC LIMIT 10
            """, tuple(params))
            if not df_pincodes.empty:
                st.markdown("#### üèÜ Top 10 Pincodes by Registered Users")
                st.dataframe(df_pincodes, use_container_width=True)

    elif sub_tab == "Insurance":
        st.subheader("üõ° Insurance Engagement Insights")

    df_total = execute_query(f"""
        SELECT SUM(Total_count) as TotalTransactions, SUM(Total_amount) as TotalAmount
        FROM aggregated_insurance {where_clause}
    """, tuple(params))

    if df_total is not None and not df_total.empty:
        total_transactions = df_total.iloc[0].get('TotalTransactions')
        total_amount = df_total.iloc[0].get('TotalAmount')

        st.metric(
            "Total Insurance Transactions",
            f"{int(total_transactions):,}" if total_transactions is not None else "data unavailable"
        )

        st.metric(
            "Total Insurance Amount (‚Çπ)",
            f"{int(total_amount):,}" if total_amount is not None else "data unavailable"
        )
    else:
        st.metric("Total Insurance Transactions", "data unavailable")
        st.metric("Total Insurance Amount (‚Çπ)", "data unavailable")

    tab1, tab2, tab3 = st.tabs(["States", "Districts", "Pincodes"])

    with tab1:
        df_states = execute_query(f"""
            SELECT States, SUM(Transaction_count) as TotalTransactions
            FROM map_insurance {where_clause}
            GROUP BY States ORDER BY TotalTransactions DESC LIMIT 10
        """, tuple(params))
        if df_states is not None and not df_states.empty:
            st.markdown("#### üèÜ Top 10 States by Insurance Transactions")
            st.dataframe(df_states, use_container_width=True)
        else:
            st.info("No state-level insurance data available.")

    with tab2:
        df_districts = execute_query(f"""
            SELECT Districts, SUM(Transaction_count) as TotalTransactions
            FROM map_insurance {where_clause}
            GROUP BY Districts ORDER BY TotalTransactions DESC LIMIT 10
        """, tuple(params))
        if df_districts is not None and not df_districts.empty:
            st.markdown("#### üèÜ Top 10 Districts by Insurance Transactions")
            st.dataframe(df_districts, use_container_width=True)
        else:
            st.info("No district-level insurance data available.")

    with tab3:
        df_pincodes = execute_query(f"""
            SELECT Pincodes, SUM(Transaction_count) as TotalTransactions
            FROM top_insurance {where_clause}
            GROUP BY Pincodes ORDER BY TotalTransactions DESC LIMIT 10
        """, tuple(params))
        if df_pincodes is not None and not df_pincodes.empty:
            st.markdown("#### üèÜ Top 10 Pincodes by Insurance Transactions")
            st.dataframe(df_pincodes, use_container_width=True)
        else:
            st.info("No pincode-level insurance data available.")





# Case Study Insights
elif section == "Case Study Dashboard":
    st.title("üìë Case Study Dashboard")
         # Year and Quarter Filters
    years = ["All"] + [str(y) for y in range(2018, 2025)]
    quarters = ["All"] + list(quarter_map.keys())

    col1, col2 = st.columns(2)
    selected_year = col1.selectbox("Select Year", years)
    selected_quarter = col2.selectbox("Select Quarter", quarters)

    year = int(selected_year) if selected_year != "All" else None
    quarter = quarter_map[selected_quarter] if selected_quarter != "All" else None

    conditions = []
    params = []

    if year is not None:
        conditions.append("Years = %s")
        params.append(year)
    if quarter is not None:
        conditions.append("Quarter = %s")
        params.append(quarter)

    where_clause = "WHERE " + " AND ".join(conditions) if conditions else ""

    case_option = st.selectbox("Select Case Study", [
        "Decoding Transaction Dynamics",
        "Device Dominance and User Engagement",
        "Insurance Penetration and Growth Potential",
        "Transaction Analysis for Market Expansion",
        "User Engagement and Growth Strategy"
    ])
    if case_option == "Decoding Transaction Dynamics":
        # 1. Average Transaction Amount by Transaction Type
        df_avg_amount = execute_query(
            f"""
            SELECT Transaction_type, AVG(Transaction_amount) AS AvgAmount 
            FROM aggregate_transaction 
            {where_clause} 
            GROUP BY Transaction_type
            """,
            tuple(params)
        )
        st.plotly_chart(
            px.bar(
                df_avg_amount, 
                x="Transaction_type", 
                y="AvgAmount", 
                title="Distribution of Transactions Across Types",
                color="Transaction_type",
                color_discrete_sequence=px.colors.sequential.Plasma
            )
        )

        # 2. Min and Max Transaction Amount Over Years
        df_min_max = execute_query(
            f"""
            SELECT Years, 
                MIN(Transaction_amount) AS MinAmount, 
                MAX(Transaction_amount) AS MaxAmount
            FROM aggregate_transaction
            {where_clause}
            GROUP BY Years
            """,
            tuple(params)
        )
        fig_min_max = px.line(
            df_min_max, 
            x="Years", 
            y=["MinAmount", "MaxAmount"], 
            markers=True,
            title="Transaction Amount Growth Over Years",
            labels={"value": "Transaction Amount", "variable": "Metric"},
            color_discrete_sequence=["green", "red"]
        )
        st.plotly_chart(fig_min_max)

        # 3. Total Transaction Amount by State (Map)
        df_amount_by_state = execute_query(
            f"""
            SELECT States, SUM(Transaction_amount) AS TotalAmount
            FROM map_transaction
            {where_clause}
            GROUP BY States
            """,
            tuple(params)
        )
        fig_amount_map = px.choropleth(
            df_amount_by_state, 
            geojson=geo, 
            locations="States", 
            featureidkey="properties.ST_NM", 
            color="TotalAmount",
            title="Geographical Distribution of Transactions",
            color_continuous_scale="Viridis"
        )
        fig_amount_map.update_geos(fitbounds="locations", visible=False)
        st.plotly_chart(fig_amount_map)

        # 4. Top 5 Transaction Types by Total Amount
        df_top_amount_types = execute_query(
            f"""
            SELECT Transaction_type, SUM(Transaction_amount) AS TotalAmount
            FROM aggregate_transaction
            {where_clause}
            GROUP BY Transaction_type
            ORDER BY TotalAmount DESC
            LIMIT 5
            """,
            tuple(params)
        )
        st.plotly_chart(
            px.bar(
                df_top_amount_types, 
                x="Transaction_type", 
                y="TotalAmount", 
                title="Leading Transaction Categories by Amount",
                color="Transaction_type",
                color_discrete_sequence=px.colors.sequential.Magenta
            )
        )

    elif case_option == "Device Dominance and User Engagement":
        df_retention_proxy = execute_query(f"""
            SELECT au.Brands, au.Years, au.Quarter, SUM(mu.AppOpens) AS AppOpens
            FROM aggregate_user au
            JOIN map_user mu ON au.States = mu.States AND au.Years = mu.Years AND au.Quarter = mu.Quarter
            {where_clause.replace('Years', 'au.Years').replace('Quarter', 'au.Quarter')}
            GROUP BY au.Brands, au.Years, au.Quarter
            ORDER BY au.Brands, au.Years, au.Quarter
        """, tuple(params))

        df_retention_proxy["Time"] = df_retention_proxy["Years"].astype(str) + "-Q" + df_retention_proxy["Quarter"].astype(str)

        st.plotly_chart(
            px.line(
                df_retention_proxy, x="Time", y="AppOpens", color="Brands", 
                title="Quarterly App Opens Trend by Brand",
                markers=True, color_discrete_sequence=px.colors.qualitative.Safe
            )
        )
        df_top_brand_state = execute_query(f"""
            SELECT States, Brands, SUM(Transaction_count) AS Users
            FROM aggregate_user
            {where_clause}
            GROUP BY States, Brands
        """, tuple(params))

        # Get the top brand per state
        df_top_brand = df_top_brand_state.loc[df_top_brand_state.groupby("States")["Users"].idxmax()]

        st.plotly_chart(
            px.bar(
                df_top_brand, x="States", y="Users", color="Brands",
                title="Most Used Device Brand by State",
                color_discrete_sequence=px.colors.qualitative.Prism
            )
        )
                

    elif case_option == "Insurance Penetration and Growth Potential":
        df_state_yearly = execute_query(
            f"SELECT States, Years, SUM(Total_count) AS TotalCount FROM aggregated_insurance {where_clause} GROUP BY States, Years",
            tuple(params)
        )
        if not df_state_yearly.empty and "TotalCount" in df_state_yearly.columns:
            fig = px.bar(
                df_state_yearly.sort_values(by="TotalCount", ascending=False),
                x="States", y="TotalCount", color="Years",
                title="Insurance Transactions by State and Year",
                barmode="group", color_discrete_sequence=px.colors.sequential.Viridis
            )
            st.plotly_chart(fig)
        else:
            st.warning("No data available for Insurance Transactions by State and Year.")

        df_avg_state = execute_query(
            f"SELECT States, AVG(Total_count) AS AvgCount FROM aggregated_insurance {where_clause} GROUP BY States",
            tuple(params)
        )
        if not df_state_yearly.empty and "TotalCount" in df_state_yearly.columns:
            st.plotly_chart(
                px.pie(
                    df_avg_state.sort_values(by="AvgCount", ascending=True).head(10),
                    names="States", values="AvgCount",
                    title="Least Penetrated States by Avg Yearly Count"
                )
            )
        else:
            st.warning("No data available for Least Penetrated States by Avg Yearly Count.")    

    elif case_option == "Transaction Analysis for Market Expansion":
        df_by_type = execute_query(f"""
            SELECT Transaction_type, SUM(Transaction_amount) AS Amount
            FROM aggregate_transaction
            {where_clause}
            GROUP BY Transaction_type
        """, tuple(params))

        st.plotly_chart(
            px.bar(
                df_by_type, x="Transaction_type", y="Amount",
                title="Transaction Value by Type",
                color_discrete_sequence=px.colors.qualitative.Dark2
            )
        )
        df_map_amt = execute_query(f"SELECT States, SUM(Transaction_amount) AS TotalAmount FROM map_transaction {where_clause} GROUP BY States", tuple(params))
        fig = px.choropleth(df_map_amt, geojson=geo, locations="States", featureidkey="properties.ST_NM", color="TotalAmount", color_continuous_scale="Purples", title="State-wise Market Value Map")
        fig.update_geos(fitbounds="locations", visible=False)
        st.plotly_chart(fig)

    elif case_option == "User Engagement and Growth Strategy":
        df_app = execute_query(f"SELECT States, SUM(AppOpens) AS Opens FROM map_user {where_clause} GROUP BY States", tuple(params))
        st.plotly_chart(px.bar(df_app.sort_values(by="Opens", ascending=False).head(10), x="States", y="Opens", title="Top States by App Opens", color="States", color_discrete_sequence=px.colors.sequential.Mint))
       
        df_districts = execute_query(f"SELECT Districts, SUM(RegisteredUser) AS Users FROM map_user {where_clause} GROUP BY Districts ORDER BY Users DESC LIMIT 10", tuple(params))
        st.plotly_chart(px.pie(df_districts, names="Districts", values="Users", title="Top Districts by Registrations Share"))

